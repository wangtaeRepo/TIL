# Solidity v0.7.0 Breaking Changes

# 솔리디티 v0.7.0 주요 변경 사항

이 섹션에서는 솔리디티 버전 0.7.0에서 주요 변경 사항과 변경 이유, 
그리고 영향을 받는 코드를 어떻게 업데이트 하는지 소개합니다.
전체 변경 사항 목록은 [the release changelog](https://github.com/ethereum/solidity/releases/tag/v0.7.0) 를 참고 하십시오.

## 의미론적 변경 사항(Silent Changes of the Semantics)  

* 리터럴이 아닌 리터럴의 지수화와 시프트(예를 들어, `1 << x` 또는 `2 ** x`)는 
항상 `uint256`을 사용합니다. (음수가 아닌 리터럴의 경우)
또는 `int256` (음수 리터럴의 경우)를 사용하여 연산합니다. 
이전에, 명령은 오해할 수 있는 시프트량(shift amount) / 지수(exponent)의 유형으로 연산이 수행되었습니다. 

## 문법적 변경 사항

* 외부 함수 및 컨트랙트 생성 호출(Contract creation calls)에서, 
Ether 및 gas는 이제 새 구문을 사용하여 지정된다. : `x.f{gas: 10000, value: 2 ether}{arg1, arg2}`  
이전 구문인 `x.f.gas(10000).value(2 ether)(arg1, arg2)`는 오류가 발생한다.
* 글로벌 변수 `now`는 더 이상 사용되지 않고, 대신에 `block.timestamp`를 사용해야 한다. 
단일 식별자 `now`는 글로벌 변수에 대해 너무 일반적이고 트랜잭션 처리 중에 변경된다는 인상을 줄 수 있는 반면 
`block.timestamp`는 블록의 속성(property)라는 사실을 올바르게 반영한다. 
* 변수에 대한 NatSpec comments는 공개(public) 상태 변수에만 허용되며 로컬 또는 내부(internal) 변수에는 
허용되지 않는다. 
* 토큰 `gwei`는 이제 키워드다. (지정하는 데 사용됨, 예: 숫자로 `2 gwei`) 그리고 식별자로서 사용될 수 없다.  
* 문자열 리터럴은 이제 인쇄 가능한(printable) ASCII 문자만 포함할 수 있으며 여기에는 16진수(`\xff`) 
및 유니코드 이스케피으(`\u20ac`)와 같은 다양한 이스케이프 시퀀스도 포함된다. 
* 이제 유요한 UTF-8 시퀀스를 수용하기 위해 유니코드 문자열 리터럴이 지원된다. 
유니코드 문자열 리터럴은 `unicode` 접두사(prefix)로 식별된다. : `unicode "Hello 😃"`  
* 상태 변경 가능성(State Mutability): 이제 상속 중에 함수의 상태 변경 가능성을 제한할 수 있다. : 
기본 상태 변경 가능성이 있는 함수는 `pure` 및 `view` 함수로 재정의할 수 있는 반면 `view` 함수는 
`pure` 함수로 재정의할 수 있다. 동시에 공개 상태 변수는 `view`로 간주되어 상수인 경우에도 `pure`이다. 

## 인라인 어셈블리

* 인라인 어셈블리에서 사용자 정의 함수 및 변수 이름에 `.`을 허용하지 않는다. 
Yul 전용 모드(Yul-only mode)에서 솔리디티를 사용하는 경우에도 여전히 유효하다. 
* 스토리지 포인터 변수 `x`의 슬롯 및 오프셋은 `x_slot` 및 `x_offset` 대신에 `x.slot` 및 `x.offset`으로 접근한다. 

## 사용하지 않거나 안전하지 않은 기능 제거

### 스토리지 외부 매핑(Mappings outside Storage)

* 구조체 또는 배열에 매핑이 포함된 경우 스토리지에서만 사용할 수 있다. 
이전에는 매핑 멤버가 메모리에서 자동으로 건너뛰어 혼란스럽고 오류가 발생하기 쉬웠다.
* 스토리지의 구조체 또는 배열에 매핑이 포함된 경우에는 할당이 작동하지 않는다. 
이전에는 복사 작업 중에 매핑을 자동으로 건너뛰어 오해의 소지가 있고 오류가 발생하기 쉬웠다.

### 함수와 이벤트

* 생성자에 더 이상 가시성(`public` / `internal`)이 필요치 않다. 계약이 생성되는 것을 방지하기 
위해 `abstract`로 표시할 수 있다. 이로 인해 생성자에 대한 가시성 개념이 더 이상 사용되지 않는다. 
* 타입 확인자(Type Checker): 라이브러리 함수에서 `virtual`을 허용하지 않는다. : 
라이브러리는 상속될 수 없으므로 라이브러리 함수는 `virtual`이 아니어야 한다. 
* 동일한 상속 계층에서 동일한 이름과 매개변수 타입을 갖는 여러 이벤트는 허용되지 않는다. 
* `using A for B`는 언급된 컨트랙트에만 영향을 미친다. 이전에는 효과가 상속되었다. 
이제 기능을 사용하는 모든 파생 컨트랙트에서 `using`문을 반복해야 한다. 

### 표현식(Expressions)

* 서명된 타입에 의한 이동(Shifts)은 허용되지 않는다. 이전에는 음수만큼의 이동이 허용되었지만 
런타임에 되돌려 진다. (reverted at runtime. )
* `finney`와 `szabo` 명칭은 제거되었다. 드물게 사용되고 실제 금액을 쉽게 볼 수 없도록 한다. 
대신에, `1e20` 또는 매우 일반적인 `gwei`같은 명시적 값을 사용할 수 있다. 

### 선언식(Declarations)

* `var` 키워드는 더 이상 사용할 수 없다. 이전에는 이 키워드를 구문 분석했지만 타입 오유와 사용할 타입에 대한 
제안이 발생했다. 이제 Parser 오류가 발생한다.  

## 인터페이스 변경 사항

* JSON AST: `kind: "hexString"`으로 16진 문자열 리터럴을 표시한다. 
* JSON AST: 값이 `null`인 멤버는 JSON 출력에서 제거된다. 
* NatSpec: 생성자와 함수에는 일관된 userdoc 출력이 있다. 

## 코드 업데이트 방법

이 섹션에서는 모든 주요 변경 사항에 대해 이전 코드를 업데이트하는 방법에 대한 자세한 지침을 제공한다.  

* `x.f.value(...)()`에서 `x.f{value: ...}()`로 변경한다. 
비슷하게 `(new C).value(...)()`에서 `new C{value: ...}()`로 그리고 `x.f.gas(...).value(...)()`에서 `x.f{gas: ..., value: ...}()`로.
* `now`에서 `block.timestamp`로 변경한다.
* 시프트 연산자의 오른쪽 피연산자의 유형을 부호 없는 타입으로 변경한다. 예를 들어 
`x >> (256 - y)`에서 `x >> uint(256 - y)`.
* 필요한 경우 파생된 모든 컨트랙트에서 `using A for B`문 사용을 반복한다. 
* 모든 생성자에서 `public` 키워드는 제거한다.
* 모든 생성자에서 `internal` 키워드는 제거하고 컨트랙트에 `abstract`를 추가한다.
  (아직 없는 경우) 
* 인라인 어셈블리의 `_slot` 및 `_offset` 접미사를 각각 `.slot` 및 `.offset`으로 변경한다.